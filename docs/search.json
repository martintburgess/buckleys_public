[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Australian election forecast model demonstration",
    "section": "",
    "text": "The code requires [tidyverse](https://www.tidyverse.org) and [rstan](../about) to be installed. \n\n\nCode\nlibrary(tidyverse)\nlibrary(rstan)\n\noptions(dplyr.summarise.inform = FALSE)"
  },
  {
    "objectID": "index.html#read-data",
    "href": "index.html#read-data",
    "title": "Australian election forecast model demonstration",
    "section": "Read data",
    "text": "Read data\nHere we read in the data and package it up so that it can be input into the stan model.\n\n\nCode\npolls <- read_csv(\"data/polls2019.csv\") |>\n  mutate(firm_index = as.numeric(as.factor(firm_coarse)))\n\nall_elections <- read_csv(\"data/election_results2019.csv\")\n\npolls_elections <- all_elections |> \n  filter(!is.na(day_index)) \n\ncrossbench <- read_csv(\"data/crossbench2019.csv\")\n\nmodel_input <- list(\n  \n  # timeseries length\n  n_days =   max(polls$day_index),\n  \n  # priors, \n  tpp_mu_prior_mu = mean(all_elections$tpp_alp),\n  tpp_mu_prior_scale = sd(all_elections$tpp_alp),\n  tpp_sigma_prior_mu = 0.0025,\n  tpp_sigma_prior_scale = 0.001,\n  tpp_coef_prior_scale = 0.05,\n  df_prior_alpha = 32/3, \n  df_prior_beta = 8/3,\n  \n  # election data for polling\n  polls_n_elections = nrow(polls_elections),\n  polls_election_days = as.array(polls_elections$day_index),\n  polls_election_tpp_alp = as.array(polls_elections$tpp_alp),\n  \n  # polling data \n  polls_n = nrow(polls),\n  polls_firms_n = length(unique(polls$firm_index)),\n  polls_firm = polls$firm_index,\n  polls_tpp_alp = polls$tpp_alp,\n  polls_standard_error = polls$tpp_alp_se,\n  polls_day = polls$day_index,\n  polls_se_inflator = 2,\n  \n  # election data for tpp2seats\n  tpp2seats_n_elections = nrow(all_elections),\n  tpp2seats_alpha_prior_mu = 0,\n  tpp2seats_alpha_prior_scale = 3,\n  tpp2seats_beta_prior_mu = 0,\n  tpp2seats_beta_prior_scale = 5,\n  tpp2seats_election_major_seats = all_elections$seats_alp + all_elections$seats_lnc,\n  tpp2seats_election_alp_seats = all_elections$seats_alp,\n  tpp2seats_election_tpp_alp = all_elections$tpp_alp,\n  \n  # data for crossbench\n  crossbench_n_elections = nrow(crossbench),\n  crossbench_retain_shots = crossbench$crossbench_running,\n  crossbench_retained = crossbench$crossbench_retain, \n  crossbench_gain_shots = crossbench$gain_opportunities,\n  crossbench_gained = crossbench$crossbench_gain\n)"
  },
  {
    "objectID": "index.html#run-model",
    "href": "index.html#run-model",
    "title": "Australian election forecast model demonstration",
    "section": "Run model",
    "text": "Run model\nHere we specify the stan code that defines the model. It can be stored in a separate file but it has been included here so that everything is in one document.\n\n\nCode\nstan_model <- \"\ndata {\n  // timeseries length\n  int<lower = 1> n_days;\n  \n  // priors \n  real<lower = 0, upper = 1> tpp_mu_prior_mu;\n  real<lower = 0> tpp_mu_prior_scale;\n  real<lower = 0> tpp_sigma_prior_mu;\n  real<lower = 0> tpp_sigma_prior_scale;\n  real<lower = 0> tpp_coef_prior_scale;\n  real<lower = 0> df_prior_alpha;\n  real<lower = 0> df_prior_beta;\n  \n  // election data for polling\n  int polls_n_elections;\n  int polls_election_days[polls_n_elections]; // days on which  elections occur\n  real polls_election_tpp_alp[polls_n_elections]; // historical election results\n  \n  // polling data\n  // total number of polls\n  int<lower=1> polls_n;\n  \n  // number of firms\n  int<lower=1> polls_firms_n;\n  \n  // pollster index\n  int<lower=1,upper=polls_firms_n> polls_firm[polls_n];\n  \n  // polling data\n  real<lower=0,upper=1> polls_tpp_alp[polls_n];\n  real<lower=0> polls_standard_error[polls_n];\n  int<lower=1> polls_day[polls_n];\n  //int<lower=1, upper=2> poll_close_to_next[polls_n];\n  \n  // polling standard error inflator\n  real<lower=1> polls_se_inflator;\n  \n  // election data for tpp2seats\n  int<lower=1> tpp2seats_n_elections;\n  real tpp2seats_alpha_prior_mu;\n  real<lower = 0> tpp2seats_alpha_prior_scale;\n  real tpp2seats_beta_prior_mu;\n  real<lower = 0> tpp2seats_beta_prior_scale;\n  int tpp2seats_election_major_seats[tpp2seats_n_elections];\n  int tpp2seats_election_alp_seats[tpp2seats_n_elections];\n  vector<lower=0, upper=1>[tpp2seats_n_elections] tpp2seats_election_tpp_alp;\n  \n  // data for crossbench model\n  int<lower=1> crossbench_n_elections;\n  int<lower=0> crossbench_retain_shots[crossbench_n_elections];\n  int crossbench_retained [crossbench_n_elections];\n  int<lower=0> crossbench_gain_shots[crossbench_n_elections];\n  int crossbench_gained [crossbench_n_elections];\n  \n}\n\nparameters {\n  \n  // tpp_margin estimate\n  vector<lower=0, upper=1>[n_days] tpp_mu;\n\n  // tpp_margin sigma\n  real<lower=0> tpp_sigma;\n\n  // degrees of freedom between days\n  real<lower=1, upper=7> student_t_df;\n\n  // house effect\n  real<lower=-1, upper=1> house_effect[polls_firms_n];\n\n  // close to next effect\n  real<lower=-1, upper=1> polling_bias;\n  \n  // tpp to seat\n  real alpha;\n  real beta;\n\n  // crossbench\n  real<lower=0, upper=1> crossbench_p_retain;\n  real<lower=0, upper=1> crossbench_p_gain;\n  \n}\n\ntransformed parameters {\n  // linear predictor\n  vector[tpp2seats_n_elections] tpp2seats_y_hat;\n  tpp2seats_y_hat = alpha + tpp2seats_election_tpp_alp * beta;\n}\n\nmodel {\n  // priors # make parameters for these\n  tpp_mu[1] ~ normal(tpp_mu_prior_mu, tpp_mu_prior_scale); // starting state space\n  tpp_sigma ~ normal(tpp_sigma_prior_mu, tpp_sigma_prior_scale);     // prior for innovation sd.\n  house_effect ~ normal(0, tpp_coef_prior_scale); // ie a fairly loose prior for house effects (on scale of [0,1])\n  polling_bias ~ normal(0, tpp_coef_prior_scale);\n\n  student_t_df ~ gamma(df_prior_alpha, df_prior_beta);\n\n  // state model\n  tpp_mu[2:n_days] ~ student_t(student_t_df, tpp_mu[1:(n_days - 1)], tpp_sigma);\n\n  // historical election results\n  for(election_i in 1:polls_n_elections){\n    polls_election_tpp_alp[election_i] ~ normal(tpp_mu[polls_election_days[election_i]], 0.0001); // we know tpp_mu very accurately on election day\n  }\n\n  //polls\n  for(poll_i in 1:polls_n){\n      polls_tpp_alp[poll_i] ~ normal(tpp_mu[polls_day[poll_i]] + house_effect[polls_firm[poll_i]] + polling_bias,  polls_standard_error[poll_i] * polls_se_inflator);\n\n  }\n\n  //  //tpp2seats\n  alpha ~ normal(tpp2seats_alpha_prior_mu, tpp2seats_alpha_prior_scale);\n  beta ~ normal(tpp2seats_beta_prior_mu, tpp2seats_beta_prior_scale);\n\n  tpp2seats_election_alp_seats ~ binomial_logit(tpp2seats_election_major_seats, tpp2seats_y_hat);\n\n  // crossbench\n  crossbench_p_retain ~ beta(5,2);\n\n  crossbench_retained ~ binomial(crossbench_retain_shots, crossbench_p_retain);\n\n  crossbench_p_gain ~ beta(1,5);\n  crossbench_gained ~ binomial(crossbench_gain_shots, crossbench_p_gain);\n}\n\"\n\n\n\n\nCode\nmodel_output <- stan(model_code = stan_model, \n                     data = model_input, \n                     chains = parallel::detectCores() - 2,\n                     cores = parallel::detectCores() - 2,\n                     control = list(max_treedepth = 11),\n                     iter = 10000,\n                     # sample_file = \"output/forecast_samples.csv\", \n                     verbose = FALSE)\n\nrm(model_output)"
  },
  {
    "objectID": "index.html#examine-outputs",
    "href": "index.html#examine-outputs",
    "title": "Australian election forecast model demonstration",
    "section": "Examine outputs",
    "text": "Examine outputs\n\n\nCode\n# load samples ------------------------------------------------------------\n\nsamples <- tibble() \n\nsample_files <- list.files(path = \"output/\",\n                           pattern = \"forecast_samples_\",\n                           full.names = TRUE)\n\nfor(file in sample_files){\n  temp <- read_csv(file,\n                   skip = 25) |> \n    filter(!is.na(accept_stat__)) |> \n    slice(-1) |> \n    slice_tail(prop = 0.5) |> \n    select(-lp__) \n  \n  samples <- bind_rows(samples, \n                       temp)\n}\n\n# generated values --------------------------------------------------------\n\nsamples_no_ts <- samples |> \n  filter(!is.na(crossbench_p_retain)) |> \n  mutate(crossbench_retain = rbinom(n(), 7, crossbench_p_retain),\n         crossbench_gain = rbinom(n(), 151-7, crossbench_p_gain), \n         crossbench_total = crossbench_retain + crossbench_gain) |> \n  mutate(majors_seats = 151 - crossbench_total)\n\nts_start <- as.Date(\"2004-10-09\") - 90\n\nlast_year_cols <- tibble(col_name = names(samples)) |> \n  filter(str_starts(col_name, \"tpp_mu\")) |> \n  separate(col = col_name, \n           into = c(NA, \"day_index\"), \n           sep = \"\\\\.\", \n           remove = FALSE) |> \n  mutate(day_index = as.numeric(day_index), \n         date = as.Date(day_index, origin = ts_start-1)) |> \n  filter(date > max(date) - 365) \n\nsamples_ts <- samples_no_ts |> \n  select(all_of(last_year_cols$col_name), \n         starts_with(\"house_effect\"),\n         polling_bias,\n         alpha, \n         beta, \n         majors_seats, \n         crossbench_total) |> \n  pivot_longer(cols = starts_with(\"tpp_mu\"),\n               names_to = \"day\", \n               values_to = \"tpp_alp\") |> \n  left_join(last_year_cols, \n            by = c(\"day\" = \"col_name\")) |> \n  mutate(p_alp_win_seat = plogis(alpha + beta*tpp_alp)) |> \n  mutate(alp_seats = rbinom(n(), majors_seats, p_alp_win_seat), \n         lnc_seats = as.integer(majors_seats - alp_seats), \n         seat_margin = lnc_seats - alp_seats) |> \n  mutate(tpp_lnc = 1 - tpp_alp, \n         tpp_margin = tpp_lnc - tpp_alp) \n\nsamples_election_date <- samples_ts |> \n  filter(date == max(date)) \n\nrm(temp, samples, samples_no_ts)\n\n\n\nOverall winner\n\n\nCode\nsamples_election_date %>%\n  count(alp_seats, lnc_seats) %>% \n  mutate(prop = n / sum(n)) %>% \n  mutate(winner = case_when(alp_seats >= 76 ~ \"ALP\",\n                            lnc_seats >= 76 ~ \"LNC\", \n                            TRUE ~ \"Minority\")) %>%\n  group_by(winner) %>% \n  summarise(prop = sum(prop))\n\n\n# A tibble: 3 × 2\n  winner    prop\n  <chr>    <dbl>\n1 ALP      0.160\n2 LNC      0.520\n3 Minority 0.320\n\n\n\n\nSeat margin\n\n\nCode\nsamples_election_date |> \n  ggplot(aes(x = seat_margin)) +\n  geom_histogram(binwidth = 1)\n\n\n\n\n\n\n\nTwo-party preferred margin\n\n\nCode\nsamples_election_date |> \n  ggplot(aes(x = tpp_margin)) +\n  geom_density()\n\n\n\n\n\n\n\nALP, LNC, crossbench seats\n\n\nCode\nsamples_election_date |> \n  count(alp_seats, lnc_seats, crossbench_total) |> \n  mutate(prop = n/sum(n)) |> \n  ggplot(aes(x = alp_seats, \n             y = lnc_seats, \n             alpha = prop)) +\n  geom_tile()\n\n\n\n\n\n\n\nChance of winning timeline\n\n\nCode\nchances_ts <- samples_ts %>% \n  filter(date > (max(date) - floor(365/2))) %>%  # last 6 months of data\n  group_by(date) %>% \n  summarise(alp_win = mean(alp_seats >=76),\n            lnc_win = mean(lnc_seats >=76),\n            minority_win = mean(lnc_seats <76 & alp_seats < 76)) %>% \n  ungroup() %>% \n  pivot_longer(cols = c(alp_win, \n                        lnc_win, \n                        minority_win),\n               names_to = \"outcome\",\n               values_to = \"chance\") %>% \n  select(date, outcome, chance)\n\nchances_ts |> \n  ggplot(aes(x = date, \n             y = chance,\n             colour = outcome)) +\n  geom_line()\n\n\n\n\n\n\n\nCode\ntpp_ts <- samples_ts %>% \n  filter(date > max(date) - as.integer(365/2)) %>% \n  pivot_longer(cols = c(tpp_alp, \n                        tpp_lnc),\n               names_to = \"party\",\n               values_to = \"tpp\") %>% \n  select(date, party, tpp) %>% \n  mutate(colour = case_when(party == \"tpp_alp\" ~ \"ALP\",\n                            party == \"tpp_lnc\" ~ \"Coalition\")) %>% \n  group_by(date, party, colour) %>% \n  summarise(tpp_50 = quantile(tpp, 0.5), \n            tpp_10 = quantile(tpp, 0.1),\n            tpp_90 = quantile(tpp, 0.9))\n\ntpp_ts |> \n  ggplot(aes(x = date, \n             y = tpp_50,\n             ymin = tpp_10, \n             ymax = tpp_90,\n             colour = party, \n             fill = party)) +\n  geom_ribbon(alpha = 0.2, \n              colour = NA) +\n  geom_line()"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "[Voltron Data](https://voltrondata.com)\n\n<a href=“https://docs.microsoft.com/en-us/azure/virtual-network/ddos-protection-overview”>Azure DDOS Protection Standard</a>\n\n\nCode\n1 + 1\n\n\n[1] 2"
  }
]