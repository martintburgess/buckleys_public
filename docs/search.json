[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Buckley’s & None Australian election forecast model",
    "section": "",
    "text": "This document demonstrates the Buckley’s & None Australian election forecasting model. It includes the stan code that defines the model and uses data in the lead up to 2019 election to demonstrate how it would have performed in that election.\nThis model is built by Martin Burgess and is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License."
  },
  {
    "objectID": "index.html#load-packages",
    "href": "index.html#load-packages",
    "title": "Buckley’s & None Australian election forecast model",
    "section": "Load packages",
    "text": "Load packages\nThe code requires tidyverse and rstan to be installed.\n\n\nCode\nlibrary(tidyverse)\nlibrary(rstan)\nlibrary(scales)\n\ntheme_set(theme_minimal())\n\noptions(dplyr.summarise.inform = FALSE)"
  },
  {
    "objectID": "index.html#read-data",
    "href": "index.html#read-data",
    "title": "Buckley’s & None Australian election forecast model",
    "section": "Read data",
    "text": "Read data\nRead in the data and package it up so that it can be input into the stan model.\n\n\nCode\npolls <- read_csv(\"data/polls2019.csv\") |>\n  mutate(firm_index = as.numeric(as.factor(firm_coarse)))\n\nall_elections <- read_csv(\"data/election_results2019.csv\")\n\npolls_elections <- all_elections |> \n  filter(!is.na(day_index)) \n\ncrossbench <- read_csv(\"data/crossbench2019.csv\")\n\nmodel_input <- list(\n  \n  # timeseries length\n  n_days =   max(polls$day_index),\n  \n  # priors, \n  tpp_mu_prior_mu = mean(all_elections$tpp_alp),\n  tpp_mu_prior_scale = sd(all_elections$tpp_alp),\n  tpp_sigma_prior_mu = 0.0025,\n  tpp_sigma_prior_scale = 0.001,\n  tpp_coef_prior_scale = 0.05,\n  df_prior_alpha = 32/3, \n  df_prior_beta = 8/3,\n  \n  # election data for polling\n  polls_n_elections = nrow(polls_elections),\n  polls_election_days = as.array(polls_elections$day_index),\n  polls_election_tpp_alp = as.array(polls_elections$tpp_alp),\n  \n  # polling data \n  polls_n = nrow(polls),\n  polls_firms_n = length(unique(polls$firm_index)),\n  polls_firm = polls$firm_index,\n  polls_tpp_alp = polls$tpp_alp,\n  polls_standard_error = polls$tpp_alp_se,\n  polls_day = polls$day_index,\n  polls_se_inflator = 2,\n  \n  # election data for tpp2seats\n  tpp2seats_n_elections = nrow(all_elections),\n  tpp2seats_alpha_prior_mu = 0,\n  tpp2seats_alpha_prior_scale = 3,\n  tpp2seats_beta_prior_mu = 0,\n  tpp2seats_beta_prior_scale = 5,\n  tpp2seats_election_major_seats = all_elections$seats_alp + all_elections$seats_lnc,\n  tpp2seats_election_alp_seats = all_elections$seats_alp,\n  tpp2seats_election_tpp_alp = all_elections$tpp_alp,\n  \n  # data for crossbench\n  crossbench_n_elections = nrow(crossbench),\n  crossbench_retain_shots = crossbench$crossbench_running,\n  crossbench_retained = crossbench$crossbench_retain, \n  crossbench_gain_shots = crossbench$gain_opportunities,\n  crossbench_gained = crossbench$crossbench_gain\n)"
  },
  {
    "objectID": "index.html#run-model",
    "href": "index.html#run-model",
    "title": "Buckley’s & None Australian election forecast model",
    "section": "Run model",
    "text": "Run model\nSpecify the stan code that defines the model. This can be stored in a separate file but it has been included here so that everything is in one document.\nThe underlying two-party preferred voting intention model was inspired by a similar model for the 2019 election built by Peter Ellis. Key changes include incorporating a hyperparameter for the degrees of freedom used between days in the bayesian state space model.\n\n\nCode\nstan_model <- \"\ndata {\n  // timeseries length\n  int<lower = 1> n_days;\n  \n  // priors \n  real<lower = 0, upper = 1> tpp_mu_prior_mu;\n  real<lower = 0> tpp_mu_prior_scale;\n  real<lower = 0> tpp_sigma_prior_mu;\n  real<lower = 0> tpp_sigma_prior_scale;\n  real<lower = 0> tpp_coef_prior_scale;\n  real<lower = 0> df_prior_alpha;\n  real<lower = 0> df_prior_beta;\n  \n  // election data for polling\n  int polls_n_elections;\n  int polls_election_days[polls_n_elections]; // days on which  elections occur\n  real polls_election_tpp_alp[polls_n_elections]; // historical election results\n  \n  // polling data\n  // total number of polls\n  int<lower=1> polls_n;\n  \n  // number of firms\n  int<lower=1> polls_firms_n;\n  \n  // pollster index\n  int<lower=1,upper=polls_firms_n> polls_firm[polls_n];\n  \n  // polling data\n  real<lower=0,upper=1> polls_tpp_alp[polls_n];\n  real<lower=0> polls_standard_error[polls_n];\n  int<lower=1> polls_day[polls_n];\n  //int<lower=1, upper=2> poll_close_to_next[polls_n];\n  \n  // polling standard error inflator\n  real<lower=1> polls_se_inflator;\n  \n  // election data for tpp2seats\n  int<lower=1> tpp2seats_n_elections;\n  real tpp2seats_alpha_prior_mu;\n  real<lower = 0> tpp2seats_alpha_prior_scale;\n  real tpp2seats_beta_prior_mu;\n  real<lower = 0> tpp2seats_beta_prior_scale;\n  int tpp2seats_election_major_seats[tpp2seats_n_elections];\n  int tpp2seats_election_alp_seats[tpp2seats_n_elections];\n  vector<lower=0, upper=1>[tpp2seats_n_elections] tpp2seats_election_tpp_alp;\n  \n  // data for crossbench model\n  int<lower=1> crossbench_n_elections;\n  int<lower=0> crossbench_retain_shots[crossbench_n_elections];\n  int crossbench_retained [crossbench_n_elections];\n  int<lower=0> crossbench_gain_shots[crossbench_n_elections];\n  int crossbench_gained [crossbench_n_elections];\n  \n}\n\nparameters {\n  \n  // tpp_margin estimate\n  vector<lower=0, upper=1>[n_days] tpp_mu;\n\n  // tpp_margin sigma\n  real<lower=0> tpp_sigma;\n\n  // degrees of freedom between days\n  real<lower=1, upper=7> student_t_df;\n\n  // house effect\n  real<lower=-1, upper=1> house_effect[polls_firms_n];\n\n  // close to next effect\n  real<lower=-1, upper=1> polling_bias;\n  \n  // tpp to seat\n  real alpha;\n  real beta;\n\n  // crossbench\n  real<lower=0, upper=1> crossbench_p_retain;\n  real<lower=0, upper=1> crossbench_p_gain;\n  \n}\n\ntransformed parameters {\n  // linear predictor\n  vector[tpp2seats_n_elections] tpp2seats_y_hat;\n  tpp2seats_y_hat = alpha + tpp2seats_election_tpp_alp * beta;\n}\n\nmodel {\n  // priors # make parameters for these\n  tpp_mu[1] ~ normal(tpp_mu_prior_mu, tpp_mu_prior_scale); // starting state space\n  tpp_sigma ~ normal(tpp_sigma_prior_mu, tpp_sigma_prior_scale);     // prior for innovation sd.\n  house_effect ~ normal(0, tpp_coef_prior_scale); // ie a fairly loose prior for house effects (on scale of [0,1])\n  polling_bias ~ normal(0, tpp_coef_prior_scale);\n\n  student_t_df ~ gamma(df_prior_alpha, df_prior_beta);\n\n  // state model\n  tpp_mu[2:n_days] ~ student_t(student_t_df, tpp_mu[1:(n_days - 1)], tpp_sigma);\n\n  // historical election results\n  for(election_i in 1:polls_n_elections){\n    polls_election_tpp_alp[election_i] ~ normal(tpp_mu[polls_election_days[election_i]], 0.0001); // we know tpp_mu very accurately on election day\n  }\n\n  //polls\n  for(poll_i in 1:polls_n){\n      polls_tpp_alp[poll_i] ~ normal(tpp_mu[polls_day[poll_i]] + house_effect[polls_firm[poll_i]] + polling_bias,  polls_standard_error[poll_i] * polls_se_inflator);\n\n  }\n\n  //  //tpp2seats\n  alpha ~ normal(tpp2seats_alpha_prior_mu, tpp2seats_alpha_prior_scale);\n  beta ~ normal(tpp2seats_beta_prior_mu, tpp2seats_beta_prior_scale);\n\n  tpp2seats_election_alp_seats ~ binomial_logit(tpp2seats_election_major_seats, tpp2seats_y_hat);\n\n  // crossbench\n  crossbench_p_retain ~ beta(5,2);\n\n  crossbench_retained ~ binomial(crossbench_retain_shots, crossbench_p_retain);\n\n  crossbench_p_gain ~ beta(1,5);\n  crossbench_gained ~ binomial(crossbench_gain_shots, crossbench_p_gain);\n}\n\"\n\n\nRun the model. If you are running this yourself you may want to change the number of chains and cores and the number of iterations (per chain). I use 8 cores so this creates 80,000 samples and we use the second half of them.\n\n\nCode\nmodel_output <- stan(model_code = stan_model, \n                     data = model_input, \n                     chains = parallel::detectCores() - 2,\n                     cores = parallel::detectCores() - 2,\n                     control = list(max_treedepth = 11),\n                     iter = 10000,\n                     sample_file = \"output/forecast_samples.csv\",\n                     verbose = FALSE)\n\nrm(model_output)"
  },
  {
    "objectID": "index.html#examine-outputs",
    "href": "index.html#examine-outputs",
    "title": "Buckley’s & None Australian election forecast model",
    "section": "Examine outputs",
    "text": "Examine outputs\nLoad samples generated by stan, discarding the first half of samples as “burn in”.\n\n\nCode\n# load samples ------------------------------------------------------------\n\nsamples <- tibble() \n\nsample_files <- list.files(path = \"output/\",\n                           pattern = \"forecast_samples_\",\n                           full.names = TRUE)\n\nfor(file in sample_files){\n  temp <- read_csv(file,\n                   skip = 25) |> \n    filter(!is.na(accept_stat__)) |> \n    slice(-1) |> \n    slice_tail(prop = 0.5) |> \n    select(-lp__) \n  \n  samples <- bind_rows(samples, \n                       temp)\n}\n\n# generated values --------------------------------------------------------\n\nsamples_no_ts <- samples |> \n  filter(!is.na(crossbench_p_retain)) |> \n  mutate(crossbench_retain = rbinom(n(), 7, crossbench_p_retain),\n         crossbench_gain = rbinom(n(), 151-7, crossbench_p_gain), \n         crossbench_total = crossbench_retain + crossbench_gain) |> \n  mutate(majors_seats = 151 - crossbench_total)\n\nts_start <- as.Date(\"2004-10-09\") - 90\n\nlast_year_cols <- tibble(col_name = names(samples)) |> \n  filter(str_starts(col_name, \"tpp_mu\")) |> \n  separate(col = col_name, \n           into = c(NA, \"day_index\"), \n           sep = \"\\\\.\", \n           remove = FALSE) |> \n  mutate(day_index = as.numeric(day_index), \n         date = as.Date(day_index, origin = ts_start-1)) |> \n  filter(date > max(date) - 365) \n\nsamples_ts <- samples_no_ts |> \n  select(all_of(last_year_cols$col_name), \n         starts_with(\"house_effect\"),\n         polling_bias,\n         alpha, \n         beta, \n         majors_seats, \n         crossbench_total) |> \n  pivot_longer(cols = starts_with(\"tpp_mu\"),\n               names_to = \"day\", \n               values_to = \"tpp_alp\") |> \n  left_join(last_year_cols, \n            by = c(\"day\" = \"col_name\")) |> \n  mutate(p_alp_win_seat = plogis(alpha + beta*tpp_alp)) |> \n  mutate(alp_seats = rbinom(n(), majors_seats, p_alp_win_seat), \n         lnc_seats = as.integer(majors_seats - alp_seats), \n         seat_margin = lnc_seats - alp_seats) |> \n  mutate(tpp_lnc = 1 - tpp_alp, \n         tpp_margin = tpp_lnc - tpp_alp) \n\nsamples_election_date <- samples_ts |> \n  filter(date == max(date)) \n\nrm(temp, samples, samples_no_ts)\n\n\n\nChance of winning\n\nOn election day\nCalculate proportion of samples for the three primary outcomes: ALP win, Liberal/National Coalition (LNC) win or minority government.\n\n\nCode\nsamples_election_date %>%\n  count(alp_seats, lnc_seats) |> \n  mutate(prop = n / sum(n)) |> \n  mutate(winner = case_when(alp_seats >= 76 ~ \"ALP\",\n                            lnc_seats >= 76 ~ \"LNC\", \n                            TRUE ~ \"Minority\")) %>%\n  group_by(winner) |> \n  summarise(prop = sum(prop))\n\n\n# A tibble: 3 × 2\n  winner    prop\n  <chr>    <dbl>\n1 ALP      0.160\n2 LNC      0.520\n3 Minority 0.320\n\n\n\n\nTimeline\n\n\nCode\nchances_ts <- samples_ts |> \n  filter(date > (max(date) - floor(365/2))) |>  # last 6 months of data\n  group_by(date) |> \n  summarise(alp_win = mean(alp_seats >=76),\n            lnc_win = mean(lnc_seats >=76),\n            minority_win = mean(lnc_seats <76 & alp_seats < 76)) |> \n  ungroup() |> \n  pivot_longer(cols = c(alp_win, \n                        lnc_win, \n                        minority_win),\n               names_to = \"outcome\",\n               values_to = \"chance\") |> \n  select(date, outcome, chance)\n\nchances_ts |> \n  ggplot(aes(x = date, \n             y = chance,\n             colour = outcome)) +\n  geom_line() + \n  scale_y_continuous(labels = percent_format(accuracy = 1))\n\n\n\n\n\n\n\n\nSeats won\n\nElection day margin between major parties\nPositive represents LNC winning more seats than ALP. Negative represents represents Labor winning more seats than the LNC.\n\n\nCode\nsamples_election_date |> \n  ggplot(aes(x = seat_margin)) +\n  geom_histogram(binwidth = 1) + \n  geom_vline(xintercept = 9, \n             colour = \"red\") + \n  annotate(\"text\", \n           x = 9+1, \n           y = Inf, \n           label = \"2019 result\", \n           colour = \"red\",\n           hjust = 0, \n           vjust = 1)\n\n\n\n\n\n\n\nElection day ALP, LNC seats\n\n\nCode\nsamples_election_date |> \n  count(alp_seats, lnc_seats, crossbench_total) |> \n  mutate(prop = n/sum(n)) |> \n  ggplot(aes(x = alp_seats, \n             y = lnc_seats, \n             fill = prop)) +\n  geom_tile() +\n  geom_point(x = 68, \n             y = 76, \n             shape = 4,\n             size = 2,\n             alpha = 0.5,\n             colour = \"red\") + \n  scale_fill_continuous(labels = percent_format(accuracy = 0.1)) +\n  annotate(\"text\", \n           x = 72, \n           y = 80, \n           colour = \"red\",\n           label = \"2019 result\",\n           hjust = 0, \n           vjust = 1)\n\n\n\n\n\n\n\nALP and LNC seats timeline\n\n\nCode\nseats_ts <- samples_ts |> \n  filter(date > max(date) - as.integer(365/2)) |> \n  pivot_longer(cols = c(alp_seats, \n                        lnc_seats),\n               names_to = \"party\",\n               values_to = \"seats\") |> \n  select(date, party, seats) |> \n  mutate(colour = case_when(party == \"alp_seats\" ~ \"ALP\",\n                            party == \"lnc_seats\" ~ \"Coalition\")) |> \n  group_by(date, party, colour) |> \n  summarise(seats_50 = quantile(seats, 0.5), \n            seats_10 = quantile(seats, 0.1),\n            seats_90 = quantile(seats, 0.9)) |> \n  mutate(across(starts_with(\"seats_\"), ~round(.x)))\n\nseats_ts |> \n  ggplot(aes(x = date, \n             y = seats_50,\n             ymin = seats_10, \n             ymax = seats_90,\n             colour = party, \n             fill = party)) +\n  geom_ribbon(alpha = 0.2, \n              colour = NA) +\n  geom_line() \n\n\n\n\n\n\n\n\nTwo-party preferred margin\n\nOn election day\nPositive represents LNC winning more of the national two-party preferred vote than the ALP. Negative represents represents Labor winning more of the two-party preferred vote than the LNC.\n\n\nCode\nsamples_election_date |> \n  ggplot(aes(x = tpp_margin)) +\n  geom_density() +\n  geom_vline(xintercept = 0.0306, \n             colour = \"red\") + \n  scale_x_continuous(labels = percent_format(accuracy = 0.1)) +\n  annotate(\"text\", \n           x = 0.0306 + 0.005, \n           y = Inf, \n           label = \"2019 result\", \n           colour = \"red\",\n           hjust = 0, \n           vjust = 1)\n\n\n\n\n\n\n\nTimeline\n\n\nCode\ntpp_ts <- samples_ts |> \n  filter(date > max(date) - as.integer(365/2)) |> \n  pivot_longer(cols = c(tpp_alp, \n                        tpp_lnc),\n               names_to = \"party\",\n               values_to = \"tpp\") |> \n  select(date, party, tpp) |> \n  mutate(colour = case_when(party == \"tpp_alp\" ~ \"ALP\",\n                            party == \"tpp_lnc\" ~ \"Coalition\")) |> \n  group_by(date, party, colour) |> \n  summarise(tpp_50 = quantile(tpp, 0.5), \n            tpp_10 = quantile(tpp, 0.1),\n            tpp_90 = quantile(tpp, 0.9))\n\ntpp_ts |> \n  ggplot(aes(x = date, \n             y = tpp_50,\n             ymin = tpp_10, \n             ymax = tpp_90,\n             colour = party, \n             fill = party)) +\n  geom_ribbon(alpha = 0.2, \n              colour = NA) +\n  geom_line() + \n  scale_y_continuous(labels = percent_format(accuracy = 1))"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Code\n1 + 1\n\n\n[1] 2"
  }
]